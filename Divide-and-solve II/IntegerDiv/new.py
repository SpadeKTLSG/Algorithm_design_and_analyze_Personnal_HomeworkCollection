# -*- coding: gbk -*- 
def integer_partition(n):  # 划分算法: 一维变二维
    dp = [[0] * (n + 1) for _ in range(n + 1)]  # 这里创建了DP数组来存储计算的整数划分算法方案数.
    # DP[i][j]表示将i划分为若干个整数之和(正整数,下不赘述),并且其中最大的正整数不超过j, 这个二维数组中对象的值为对应的方案数.

    for i in range(1, n + 1):  # 初始化DP数组作用: 这实际上是通过常识设定程序运行的界限,减轻计算压力
        dp[i][i] = 1  # 很简单: 把4划分, 如果里面有4这个元素它本身, 那么它绝对只有一种划分方法: 4自己.
        dp[i][1] = 1  # 很容易: 把4划分, 里面最大数是1的只可能都是1,即只有一种方案.

    # 核心操作:对DP数组
    for i in range(3, n + 1):  # i从3循环到n,判断其余元素.
        for j in range(2, i):  # j从2循环到i-1, 用来枚举最大的正整数j, 肯定从2开始,一直到i以下
            if i - j >= j:  # 比较零散的分法:划分为由j组成的若干个正整数的和.
                dp[i][j] = dp[i - j][j] + dp[i - j][j - 1]
            else:  # 比较紧凑的分法:划分为由i-j和最大正整数小于j的若干整数之和
                dp[i][j] = dp[i - j][i - j] + dp[i - j][j - 1] if (i - j != j - 1) | (j % 2 != 0) else dp[i - j][i - j]
    return sum(dp[n][:n + 1])  # dp[n][j]表示将n划分,最大正整数不超过j的方案, 因为超不过n就这样可以了.


# 经过反复调试,这里检测到了一个问题: Dp[5][2]元素的值计算为3,实际上只有2( 221和21111两种划分 ). 获得3结果的路径是DP[3][1]+DP[3][2]=1+2=3.
# 问题对应的2个DP元素相加的含义是: {111}+({21}+{12})=3个, 很明显是DP[3][2]重复了.
# 那么去检查DP[3][2]的生命周期, 发现:  dp[i - j][i - j] 和 dp[i - j][j - 1]是重复的, 故猜测问题出在这里.添加去重器.

# 接下来问题出在DP[5][3] = 311 & 32 本该是2,这里计算为1 来自: [2][2] + [2][2]本该是2 ,触发了查重,结果只有1. 这下又是查重器的问题了
# 啊这,手算后好像是要加上一个j%2来控制的(胡言乱语)
# 最后就成了这样....Help!

print(integer_partition(6))
print(integer_partition(5))  # 输出7   5, 4+1, 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1
print(integer_partition(4))  # 输出5      4, 3+1, 2+2, 2+1+1, 1+1+1+1
print(integer_partition(3), "分治选手:")  # 输出3         3 , 2+1 , 1+1+1


# 9 (错了,应该是11,说明改了代码还是错.)
# 7
# 5
# 3
